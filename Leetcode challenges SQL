This file is dedicated to the process of solving SQL challenges from the Leetcode. 


ds

                                   SECTION:
                                    SELECT
___________________________________________________________________________________________________________________________________________

1. 1757. Recyclable and Low Fat Products 
Task: product_id is the primary key (column with unique values) for this table.
low_fats is an ENUM (category) of type ('Y', 'N') where 'Y' means this product is low fat and 'N' means it is not.
recyclable is an ENUM (category) of types ('Y', 'N') where 'Y' means this product is recyclable and 'N' means it is not.

- Write a solution to find the ids of products that are both low fat and recyclable.


CODE : 

1sr trial : 

SELECT
  product_id
FROM Products
WHERE low_fats = "Y" AND 
WHERE recyclable = "Y";
______________________________---

2nd with Correction :

SELECT
  product_id
FROM Products
WHERE low_fats = "Y" AND recyclable = "Y";
_______________________________-

Thoughts and Understanding of the exercise : 

In the 1st trial I used 2 WHERE clause like I confused again it with CASE WHEN conditioning 
where we repeat that code CASE WHEN, but it seems that when you use WHERE clause it is only possible 
to use one time, and further set your condition. That's it. 









2. 584. Find Customer Referee

In SQL, id is the primary key column for this table.
Each row of this table indicates the id of a customer, their name, and the id of the customer who referred them.

Task:Find the names of the customer that are not referred by the customer with id = 2.
______________

Trials that did not work:

SELECT name
FROM Customer
WHERE referee_id !=2 
____________________
SELECT name
FROM Customer
WHERE referee_id <> 2 ;
________________

SELECT name
FROM Customer
WHERE referee_id <> 2 ;
______________________________________________

Correct Solution : 

SELECT name
FROM Customer
WHERE referee_id !=2 OR referee_id IS NULL;
____________________

THOUGHTS : 

As I see it is super important to be attentive to every detail of the challenge. The intuitive part of this exercise 
was that, correctly I used the (SELECT statement) and I was a bit confused with the filtering part with the WHERE clause,
at the beginning I was thinking let's use the = (equal operator) like setting the conditon to match to NULL and 1 . But asked
CHAT GPT how can I filter in SQL for example, I did not say give me the answer, but learned from other examples, how can 
we filter the where clause, for example , let say we dont want to include a particular value, we can simply like use the sign
!= (exclamation mark and equa) or <>  (greater or less) sign to exclude the value. It was true that way. But imagine, in that particular
column we have also NULL values. we need to use the logical operator (OR) and write the column name and write (IS NULL). To filter
we are saying exclude 2 and include all and null values also. That's it. 









3. 595. Big Countries

Challenge : 

A country is big if:

it has an area of at least three million (i.e., 3000000 km2), or
it has a population of at least twenty-five million (i.e., 25000000).
Write a solution to find the name, population, and area of the big countries.


Trials :
_______________
SELECT
    name,
    population,
    area
FROM World
WHERE area =>3000000 AND population => 25000000;

________________________________________________________
Final solution: 

SELECT
    name,
    population,
    area
FROM World
WHERE area >=3000000 OR population >= 25000000;
_________________________________

Thoughts: 
It took me not very long it complete the exercise, I put everything correctly just forgot the order of logical operators, in this case when we look for any value at least in
the challenge  we have to put first the greater operator (>) then the equal(=) operator always this is the correct syntax. And the second thing was to be attantive what the exercise
asks to do. I used the AND logical operator instead of OR. When I looked at the exercise again I realized I need to use the OR logical operator. Thats it. 







4. 1148. Article Views I
There is no primary key (column with unique values) for this table, the table may have duplicate rows.
Each row of this table indicates that some viewer viewed an article (written by some author) on some date. 
Note that equal author_id and viewer_id indicate the same person.

- Write a solution to find all the authors that viewed
at least one of their own articles.


CODE:
_______________
Trial (1): 

SELECT DISTINCT            
    viewer_id,
    author_id, 
    article_id 
FROM Views
ORDER BY viewer_id ASC;
____________________________________________________
 Trial (2):

SELECT DISTINCT             
    article_id,
    author_id,
    viewer_id,
    view_date
FROM Views
ORDER BY viewer_id ASC;

_________________________________________________________
SOLUTION: 

SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY id ASC;

Thoughts on the learning process:

Why it was so simple but I couldn't get the logic, I mean I guessed that it is (author_id & viewer_id) I need to focus on,
however instead of using the where clause to filter the values in those columns which are the same. I did instead the CONCAT function,
with concat I achieved only AS id 7 that's it. It seems that I was counting the whole rows not finding or filtering the same id. This
solution seems very easy but I was a bit confused and I would be honest did not get it appropriately. If I see the solution now step by
step if I try to understand it . Let's do it now. In the 1st line of code we write SELECT statement with DISTINCT we filter the author_id
by saying that return it only once and don't repeat it. Then we filter the author id and find where it equals to viewer_id. 









5. 1683. Invalid Tweets

tweet_id is the primary key (column with unique values) for this table. content consists of alphanumeric 
characters, '!', or ' ' and no other special characters. This table contains all the tweets in a social media app.


TASK: 

1. Write a solution to find the IDs of the invalid tweets. 
2.The tweet is invalid if the number of characters used in the content of the tweet is strictly greater than 15. 
3.Return the result table in any order.

Input: 

| tweet_id | content                           |
| -------- | --------------------------------- |
| 1        | Let us Code                       |
| 2        | More than fifteen chars are here! |


Trials:
____________

SELECT tweet_id
FROM Tweets
WHERE tweet_id = 2;

-------/ /--------

SELECT tweet_id
FROM Tweets
WHERE LENGTH (tweet_id) >15;

__________
SOLUTION:

SELECT tweet_id
FROM Tweets
WHERE LENGTH (content) >15;


_______________
LEARNING PROCESS:

With my trial code it was like drifting around and coding intuitivly like normally I do . However, if we pay 
attantion to the question closely it says the column is invalid if nb of characters is greater than 15. So what I can try now is ask
CHATGPT how do we filter with WHERE clause the nb of characters within column. Since I checked the answer is in any columns, we can count the
number of values in the column like any characters with the LENGTH(column_name) function. I wrote the code and run the excercise. But it still
showed an error then I though what was the issue. It seemed that I checked the wrong column , I had to check the content column. When doing
that I got the correct answer. Great job. 






                                          SECTION:
                                        BASIC JOINS 
___________________________________________________________________________________________________________________________________________




6. 1378. Replace Employee ID With The Unique Identifier

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| name          | varchar |
+---------------+---------+
id is the primary key (column with unique values) for this table.
Each row of this table contains the id and the name of an employee in a company.

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| unique_id     | int     |
+---------------+---------+
(id, unique_id) is the primary key (combination of columns with unique values) for this table.
Each row of this table contains the id and the corresponding unique id of an employee in the company.
 

Write a solution to :

1. Show the unique ID of each user, 
2. If a user does not have a unique ID replace just show null.



Return the result table in any order.


                                          
TRIALS :

SELECT Employees.id, EmployeeUNI.id,EmployeeUNI.unique_id
FROM Employees
JOIN EmployeeUNI
    ON Employees.id = EmployeeUNI.id
AND Employees.id = EmployeeUNI.unique_id;


             (2)
SELECT Employees.id, Employees.name
FROM Employees
LEFT JOIN EmployeeUNI
    ON Employees.id = EmployeeUNI.id
AND Employees.id = EmployeeUNI.unique_id;



SOLUTION:

SELECT EmployeeUNI.unique_id, Employees.name
FROM Employees
LEFT JOIN EmployeeUNI
ON Employees.id = EmployeeUNI.id;


LEARNING PROCESS:

So this is only the draft of the join I am trying to do. Since we do the join on two columns, we also need to include
the second column  with the AND operator. Since I tried with the AND operator it did not work. Then I tried different 
option and it worked as usual we work with the joins , basically we joined the tables on ID and showed unique_id column,
and the name of the table. It was not complicated but I made it a bit complicated . Anyway resolved the question. 













7. 1068. Product Sales Analysis I 
+-------------+-------+
| Column Name | Type  |
+-------------+-------+
| sale_id     | int   |
| product_id  | int   |
| year        | int   |
| quantity    | int   |
| price       | int   |
+-------------+-------+
(sale_id, year) is the primary key (combination of columns with unique values) of this table.
product_id is a foreign key (reference column) to Product table.
Each row of this table shows a sale on the product product_id in a certain year.
Note that the price is per unit.

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| product_id   | int     |
| product_name | varchar |
+--------------+---------+
product_id is the primary key (column with unique values) of this table.
Each row of this table indicates the product name of each product.
 

Write a solution to report the product_name, year, and price for each sale_id in the Sales table.

Return the resulting table in any order.


TRIALS:

SOLUTION:

SELECT Product.product_name, Sales.year, Sales.price
FROM Sales
LEFT JOIN Product
ON Sales.product_id = Product.product_id; 

LEARNING PROCESS:

In this SQL code, I solved the challegne in the first trial without any mistakes. It's interesting to see this development. Seemed very basic. 
We had Sales and Product tables joined on the product_id, since it was the primary key for both tables. If I am not mistaken, we join tables
on primary keys since they return the unique values for of the table and will not repeat the values. The good part is I resolved the code
easily, but it is super important to understand why it works the way it does. We joined basically the product table with the Sales table. In this code Sales 
table is our main table, meaning the primary key in this code is Sales product_id and the Product table product_id would be our foreign key,
Why? Because our main table is SALES, we determine the main table when we use the table next to the FROM clause, when we use next to the JOIN 
clause, the table it  would be our secondary. Also it is important to see the relationship. For example, what we want to show as a column. We
are showing the product name, sales_year, and sales_price. It implies  that the relationship between tables is one-to-many, meaning the name of
the product is related to many columns in the Sales table, such as Year and Price. 











8. 1581. Customer Who Visited but Did Not Make Any Transactions
Table: Visits

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| visit_id    | int     |
| customer_id | int     |
+-------------+---------+
visit_id is the column with unique values for this table.
This table contains information about the customers who visited the mall.

Table: Transactions

+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| transaction_id | int     |
| visit_id       | int     |
| amount         | int     |
+----------------+---------+
transaction_id is column with unique values for this table.
This table contains information about the transactions made during the visit_id.
 

Write a solution to :

1. find the IDs of the users who visited without making any transactions 
2. and the number of times they made these types of visits.



TRIALS:

SELECT Visits.customer_id, Transactions.amount AS count_no_trans
FROM Visits
LEFT JOIN Transactions
ON Visits.visit_id = Transactions.visit_id;

(2)

SELECT Visits.customer_id, Transactions.transaction_id AS count_no_trans
FROM Visits
JOIN Transactions
ON Visits.visit_id = Transactions.visit_id;

Trial (3)
You said:
SELECT  Visits.customer_id, transactions.transaction_id, COUNT(*) AS count_no_trans
FROM Visits
left JOIN Transactions
ON Visits.visit_id = Transactions.visit_id
where transaction_id IS NULL ;
SOLUTION:

SELECT 
  Visits.customer_id, 
  COUNT(*) AS count_no_trans
FROM Visits
LEFT JOIN Transactions
  ON Visits.visit_id = Transactions.visit_id
WHERE Transactions.transaction_id IS NULL
GROUP BY Visits.customer_id;


LEARNING PROCESS:

This is a bit challenging, but I must pay attention to the details. I was just doing it intuitively, not thinking and breaking down the question.
Please continue breaking down the question. This one I tried many times, like 10 trials, but could not get the right answer
Here you can see that in the trials there I did until there and gave for CHATGPT to correct me. My query was almost right.
I did not consider several things: 
  1. I don't need to repeat the transaction_id column, just with COUNT(*) clause , and at the end with WHERE clause I am already 
filtering the rows. 
2. I forgot to include the group by function ,why it is important, without group by we get the total number of people who entered with no
tranactions, but with group by customer_id, we see who did not make transaction how many times per cutomer_id. 
I don't know if I did the right thing by asking CHATGPT to help me with code, I dont know but anyway I am getting it. 










8. 197. Rising Temperature
Table: Weather

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| recordDate    | date    |
| temperature   | int     |
+---------------+---------+
id is the column with unique values for this table.
There are no different rows with the same recordDate.
This table contains information about the temperature on a certain day.
 

Write a solution to find :

1. all dates' id 
2. with higher temperatures 
3. compared to its previous dates (yesterday).

Return the result table in any order.

The result format is in the following example.


TRIALS:


SOLUTION:
                          SELF-JOIN
1  SELECT w1.id
2  FROM Weather w1
3  JOIN Weather w2
4   ON DATEDIFF(w1.recordDate, w2.recordDate) = 1
5  WHERE w1.temperature > w2.temperature;
                           SUB QUERY
SELECT 
    w1.id
FROM 
    Weather w1
WHERE 
    w1.temperature > (
        SELECT 
            w2.temperature
        FROM 
            Weather w2
        WHERE 
            w2.recordDate = DATE_SUB(w1.recordDate, INTERVAL 1 DAY)
    );
                      Cartesian Product or (CROSS JOIN), and WHERE clause. 
SELECT 
    w2.id
FROM 
    Weather w1, Weather w2
WHERE 
    DATEDIFF(w2.recordDate, w1.recordDate) = 1 
AND 
    w2.temperature > w1.temperature;
                                      CTE (Common Table Expressions)

WITH PreviousWeatherData AS
(
    SELECT 
        id,
        recordDate,
        temperature, 
        LAG(temperature, 1) OVER (ORDER BY recordDate) AS PreviousTemperature,
        LAG(recordDate, 1) OVER (ORDER BY recordDate) AS PreviousRecordDate
    FROM 
        Weather
)
SELECT 
    id 
FROM 
    PreviousWeatherData
WHERE 
    temperature > PreviousTemperature
AND 
    recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY);



LEARNING PROCESS:

The exercise seemed super easy, but was difficult to understand because I have no idea how we (find all the dates'id with higher
temperatures compared to the previous day.) I went right away to Chatgpt and asked, because I never had this type of 
challenge. Now I get the code that I would never get my answer to this stage, but anyway. Let me share my thoughts, how I understand 
this code. The question has one table; it does not tell me implicitly that you need to do a self-join, but the exercise is written as 
self-join code. The first line of code is we are selecting from the weather table id with alias w1.id, so in the 2nd line of code, you 
have the tableweather which has an we created alias w1, it seems that we can also simply put the alias next to the table without the "AS".
In the 3rd line of code joins the table with itself by doing a self-join and creating an alias of Weather (w2). Now in the 4th line, we
are joining on recorddate, but we are doing something different this time. Like we are not doing the usual join to find the matching rows.
In this case, we are with the DATEDIFF function to get the date difference in 1 day, and then we are comparing today’s temperature with 
yesterday’s temperature.. With the WHERE clause, we are filtering temperatures and asking give us only those rows where the temperature 
is greater than the previous day. This was my understanding of the code. What we did was time series analysis with temperature. Actually 
there were different options for resolving this problem, such as with Common Table Expression (CTE), Subquery, and Cartesian Product, and 
Where clause. 







9. 1661. Average Time of Process per Machine

There is a factory website that has several machines each running the same number of processes. Write a solution to find the average 
time each machine takes to complete a process.

The time to complete a process is the 'end' timestamp minus the 'start' timestamp. The average time is calculated by the total 
time to complete every process on the machine divided by the number of processes that were run.

The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal 
places.
Return the result table in any order.

TRIALS:

WITH duration AS (
  SELECT 
    machine_id,
    process_id,
    activity_type,
    MAX(CASE WHEN activity_type = 'end' THEN timestamp END) -
    MIN(CASE WHEN activity_type = 'start' THEN timestamp END) AS total_duration
    FROM Activity
    GROUP BY machine_id, process_id, activity_type
)
SELECT DISTINCT
machine_id,
AVG(total_duration) AS processing_time
FROM duration
GROUP BY machine_id, process_id, activity_type;
_______________________________________________________

CODE SOLUTION: 

WITH duration AS (
  SELECT 
    machine_id,
    process_id,
    activity_type,
    MAX(CASE WHEN activity_type = 'end' THEN timestamp END) -
    MIN(CASE WHEN activity_type = 'start' THEN timestamp END) AS total_duration
    FROM Activity
    GROUP BY machine_id, process_id
)
SELECT DISTINCT
machine_id,
ROUND(AVG(total_duration),3) AS processing_time
FROM duration
GROUP BY machine_id;


LEARNING PROCESS:


In this challenge, I used CTE, as I understood calculating the timestamp and other complex things we need, CTE, that's why
I looked at Chatgpt to give me the syntax for the CTE. How can we calculate the total duration? So basically, we start writing the code
with the opening WITH clause of the CTE, we name our temporary table, in our case is duration and then with write the AS keyword 
and open the parenthesis, then we select our columns, with CASE WHEN we count the total duration by counting the max of end and min of start, 
We are counting the exact max of end time because there might be many ends which are different in seconds or minutes, that's why where are 
being accurate with that part. We group by machine_id and process_id. So one mistake I made was that I grouped by activity also, but it 
seemed that. It was not necessary because we are counting the activity type and the duration, so we would not need this; otherwise, we would 
get null values. 




________________




10. 577. Employee Bonus

Table: Employee

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| empId       | int     |
| name        | varchar |
| supervisor  | int     |
| salary      | int     |
+-------------+---------+
empId is the column with unique values for this table.
Each row of this table indicates the name and the ID of an employee in addition to their salary and the id of their manager.

Table: Bonus

+-------------+------+
| Column Name | Type |
+-------------+------+
| empId       | int  |
| bonus       | int  |
+-------------+------+
empId is the column of unique values for this table.
empId is a foreign key (reference column) to empId from the Employee table.
Each row of this table contains the id of an employee and their respective bonus.
 

Write a solution to report the name and bonus amount of each employee with a bonus less than 1000.



TRIALS:

SELECT Employee.name, Bonus.bonus
FROM Employee
LEFT JOIN Bonus
ON Employee.empID = Bonus.empID
WHERE bonus < 1000;


SOLUTION:

(1)
SELECT Employee.name, Bonus.bonus
FROM Employee
LEFT JOIN Bonus
ON Employee.empID = Bonus.empID
WHERE bonus IS NULL OR bonus < 1000;

(2)

WITH EmployeeBonus AS (
    SELECT Employee.name, Bonus.bonus
    FROM Employee
    LEFT JOIN Bonus
    ON Employee.empID = Bonus.empID
)
SELECT name, bonus
FROM EmployeeBonus
WHERE bonus IS NULL OR bonus < 1000;


THOUGHTS:

The challenge seemed very easy, I tried and solved it in 17 minutes, which I am proud of myself. One part of this problem that confused me
was the filtering part with the condition where I filtered only one time but it seems that it is also we can filter two time with WHERE clause
using OR operator to give the second condition. So what we do is basically write the WHERE clause and the column is for instance equal to 90
OR the column is null also and thats is. So another option would be to make the full outer join but in MySQL it does not work we need to use
UNION ALL for that. But I used this simple solution for it. Now I am curious if I can solve this with CTE. Here I got the CTE version also,
but generally, as I see it, if the WHERE clause makes a clear filter that's fine. Let it be like that. No Neet to make it more complext with
CTE. 


11. 1280. Students and Examinations

Write a solution to find the number of times each student attended each exam.

Return the result table ordered by student_id and subject_name.


TRIALS: 

SELECT 
    Students.student_id, 
    Students.student_name, 
    Subjects.subject_name
     COUNT()AS attended_exams
     FROM Students
     LEFT JOIN Examinations
     ON Students.students_id = Examinations.student_id
     LEFT JOIN Examinations.subject_name = Subjects.subject_name
     ORDER BY student_id, subject_name ASC;
(2)
SELECT 
    Students.student_id, 
    Students.student_name,
    Subjects.subject_name,
 COUNT(Examinations.student_id) AS attended_exams
     FROM 
        Students
    LEFT JOIN  
        Examinations 
    ON Students.student_id = Examinations.student_id
    LEFT JOIN 
        Subjects
    ON Examinations.subject_name = Subjects.subject_name
    ORDER BY student_id, subject_name ASC;

(3)

SELECT
Students.student_id,
Students.student_name,
Subjects.subject_name,
Students.student_id AS attended_exams
FROM Subjects
LEFT JOIN  Examinations 
ON Subjects.subject_name = Examinations.subject_name
CROSS JOIN Students
ON Students.student_id = Examinations.student_id
GROUP BY Students.student_id, Subjects.subject_name
ORDER BY Students.student_id, Subjects.subject_name;

________



SOLUTION:

(1)

SELECT
Students.student_id,
Students.student_name,
Subjects.subject_name,
COUNT(Examinations.subject_name) AS attended_exams
FROM Students
CROSS JOIN  Subjects 
LEFT JOIN Examinations 
    ON Students.student_id = Examinations.student_id
    AND Subjects.subject_name = Examinations.subject_name
GROUP BY Students.student_id, Subjects.subject_name
ORDER BY Students.student_id, Subjects.subject_name;

(2) With CTE

WITH joined_tables AS (
    SELECT
        Students.student_id,
        Students.student_name,
        Examinations.subject_name
    FROM Students
    LEFT JOIN Examinations
        ON Students.student_id = Examinations.student_id
)
SELECT
    Students.student_id,
    Students.student_name,
    Subjects.subject_name,
    COUNT(joined_tables.subject_name) AS attended_exams
FROM Students
CROSS JOIN Subjects
LEFT JOIN joined_tables
    ON Students.student_id = joined_tables.student_id
    AND Subjects.subject_name = joined_tables.subject_name
GROUP BY Students.student_id, Students.student_name, Subjects.subject_name
ORDER BY Students.student_id, Students.student_name, Subjects.subject_name;


THOUGHTS: 
Very complex query in terms of conceptual understanding. Try to come back to this code later and understand it . It is a bit complex and get
more theoretical understanding. I fixed it somehow but could not understand it. 










12. 570. Managers with at Least 5 Direct Reports 

Table: Employee

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
| department  | varchar |
| managerId   | int     |
+-------------+---------+
id is the primary key (column with unique values) for this table.
Each row of this table indicates the name of an employee, their department, and the id of their manager.
If managerId is null, then the employee does not have a manager.
No employee will be the manager of themself.
 

Write a solution to find managers with at least five direct reports.


SOLUTIONS:

(1)

SELECT E.name
FROM Employee E
JOIN (
    SELECT managerId
    FROM Employee
    WHERE managerId IS NOT NULL
    GROUP BY managerId
    HAVING COUNT(*) >= 5
) AS managers
ON E.id = managers.managerId;

_____________________________________________
(2) CTE

WITH Managers AS (
    SELECT managerId
    FROM Employee
    WHERE managerId IS NOT NULL
    GROUP BY managerId
    HAVING COUNT(*) >= 5
)
SELECT E.name
FROM Employee E
JOIN Managers M
    ON E.id = M.managerId;





13. 1934. Confirmation Rate 

The confirmation rate of a user is the number of 'confirmed' messages divided by the total number of requested confirmation messages. 
The confirmation rate of a user that did not request any confirmation messages is 0. Round the confirmation rate to two decimal places.

Write a solution to find the confirmation rate of each user.

Return the result table in any order.


TRIALS:

SOLUTION:

WITH user_actions AS (
SELECT
    Signups.user_id,
    Confirmations.action
FROM Signups
LEFT JOIN Confirmations
    ON Signups.user_id = Confirmations.user_id
),
user_counts AS(
SELECT
    user_id,
    COUNT(*) AS total_actions,
    SUM(CASE WHEN action = "confirmed" THEN 1 ELSE 0 END) AS total_confirmed
FROM user_actions
GROUP BY user_id
)

SELECT
    user_id,
    ROUND((total_confirmed / total_actions),2) AS confirmation_rate
    FROM user_counts
    WHERE total_actions >0
    GROUP BY user_id;


THROUGHTS:








                                SECTION : Basic Aggregate Functions
__________________________________________________________________________________________________________________________________



14. 

620. Not Boring Movies

Table: Cinema

+----------------+----------+
| Column Name    | Type     |
+----------------+----------+
| id             | int      |
| movie          | varchar  |
| description    | varchar  |
| rating         | float    |
+----------------+----------+
id is the primary key (column with unique values) for this table.
Each row contains information about the name of a movie, its genre, and its rating.
rating is a 2 decimal places float in the range [0, 10]
 

Write a solution to report the movies with an 
1. odd-numbered ID and a 
2. Description that is not "boring".

Return the result table ordered by rating in descending order.


                                                TRIALS:

SELECT *
FROM Cinema
WHERE id % 2 = 1 AND description != "boring"

                                                  SOLUTION:

SELECT *
FROM Cinema
WHERE id % 2 = 1 AND description != "boring"
ORDER BY rating DESC;

                                                  THOUGHTS:
The SQL challenge was not difficult this time, I managed to do it fast. What I realized that it is important to understand the question
well. In this context, first, I was asked to report the movies with an odd-numbered ID. So I looked it and find out that odd numbers are
the numbers not divisible by 2 . So in sql to check that condition we use (%2=1), saying that I need odd number id like 1,3,5. Secondly,
filtering the description part where is says it is not boring, in SQL is not equal (!=) eather exclamation mark and greater or less (<>).
So yes I used the AND operator and filtered twice. Thats it. 







15.

1251. Average Selling Price


Write a solution to 

1. find the average selling price for each product. 
2. average_price should be rounded to 2 decimal places. 
3. If a product does not have any sold units, its average selling price is assumed to be 0.

Return the result table in any order.


TRIALS:
(1)

SELECT 
    Prices.product_id,
    SUM(Prices.price)/ SUM (UnitsSold.units) AS average_price
FROM Prices 
LEFT JOIN UnitsSold
ON Prices.product_id = UnitsSold.product_id
GROUP BY product_id;

(2)
SELECT DISTINCT
    Prices.product_id,
    SUM(Prices.price)/ COUNT(UnitsSold.units) AS average_price
FROM Prices 
LEFT JOIN UnitsSold
ON Prices.product_id = UnitsSold.product_id
GROUP BY product_id


SOLUTION:
___________________
SELECT
p.product_id,
ROUND(COALESCE(SUM(us.units * p.price) / NULLIF(SUM(us.units), 0), 0),2) AS average_price
FROM Prices p
LEFT JOIN UnitsSold us
ON p.product_id = us.product_id
AND us.purchase_date BETWEEN p.start_date AND p.end_date
GROUP BY p.product_id;
_______________________________________________________________________________

THOUGHTS: now start with the basic of understanding and then think about the solution again. That is actually an interesting challenge it
took me while to resolve it and come to it. We generally with the

1. ROUND function rounding our average price to two decimal

2. We sum how many units is sold by its price, for example product_id number 1 has sold 100 units for 5$ so what we de is multiply
sale's unit by its price like (100*5)

3. With NULLIF, we are saying that count the SUM of the units but if it is 0 turns the divisor into  NULL, so that to prevent "divizion 
by zero error". Thats actually another concept to understand how it works.


4. Aslo it is important to understand on the top of our join we did a filter with time-based condition extending the join and joing
our columns based on the purchase date between sart and end date. It is obviously a new concept for me but it is very common when analysing
subscription period, promotions, and time based pricing. 










____________

1075. Project Employees I

Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.

Return the result table in any order.

TRIALS:

WITH project_employee AS (
SELECT
    Project.project_id,
    Employee.employee_id,
    Employee.name,
    Employee.experience_years
FROM Project
LEFT JOIN Employee
ON Project.employee_id = Employee.employee_id
GROUP BY Project.project_id,Employee.employee_id
)
SELECT
    project_id,
    ROUND(AVG(experience_years),2) AS average_years
FROM project_employee
GROUP BY project_id;

SOLUTION 

                                 (1)

WITH project_employee AS (
SELECT
    Project.project_id,
    Employee.employee_id,
    Employee.name,
    Employee.experience_years
FROM Project
JOIN Employee
ON Project.employee_id = Employee.employee_id
)
SELECT
    project_id,
    ROUND(AVG(experience_years),2) AS average_years
FROM project_employee
GROUP BY project_id;


                                  (2)

SELECT 
    project_id,
    ROUND(AVG(experience_years), 2) AS average_years
FROM 
    Project p
JOIN 
    Employee e
ON 
    p.employee_id = e.employee_id
GROUP BY 
    project_id

THOUGHTS:

The excercise was pretty intuitive. I have got it right. The only thing was it I did a mistake in the CTE is that I used the group by
function, we always use group by with aggregation like sum, avg, or count . In the fist CTE there was no need to group by. 

Also I did left join, actually. it was also completed with join . 

So now what is the difference between left and inner join ?
_______________________________________________________
      LEFT JOIN - returns all the rows from the left table plus matching rows from the right table (left is always when we use FROM clause),
if there is not match in the right table, the result will show still in the left table row, but show nulls in the right table. 


INNER JOIN - returns all the matching rows from the left and right tables , if a row in the left tables doesn not have matching rows from the 
right table it will not appear in the result.

NOTE : this is for me to refresh my memory. Now we can continue with the next challenge.



_______________________


    1633. Percentage of Users Attended a Contest


Write a solution 

1. to find the percentage of the users registered in each contest 
2. rounded to two decimals.
3. Return the result table ordered by percentage in descending order. 
4. In case of a tie, order it by contest_id in ascending order.


TRIALS

(1)

WITH registered AS(
SELECT 
    Register.user_id,
    Register.contest_id,
    COUNT(*) AS contest_count
FROM Users
JOIN Register
ON Users.user_id = Register.user_id
)
SELECT
    contest_id,
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM registered) AS percentage
FROM registered
GROUP BY contest_id, user_id
ORDER BY percentage DESC;


SOLUTION:

(1)

WITH contest_users AS (
    SELECT 
        r.contest_id,
        COUNT(DISTINCT r.user_id) AS user_count,
        (SELECT COUNT(*) FROM Users) AS total_count
    FROM Register r
    GROUP BY r.contest_id
)
SELECT 
    contest_id,
    ROUND(user_count / total_count * 100, 2) AS percentage
FROM contest_users
ORDER BY percentage DESC, contest_id ASC;


(2)

SELECT 
    r.contest_id,
    ROUND(COUNT(DISTINCT r.user_id) / (SELECT COUNT(*) FROM Users) * 100, 2) AS percentage
FROM Register r
GROUP BY r.contest_id
ORDER BY percentage DESC,
r.contest_id ASC;


THOUGHTS:

This challenge is a bit difficult , I did try with my intuition like the fist think , like I did the previous excercise which worked,
but this seems different. I need to fist understand how the percetage counting works in MYSQL . I need to study it fist and then
try again to solve the problem. Need to come back again to this challenge. 






_______________


1211. Queries Quality and Percentage


Write a solution to find each query_name, the quality and poor_query_percentage.

Both quality and poor_query_percentage should be rounded to 2 decimal places.

Return the result table in any order.


TRIALS:

SOLUTION:



SELECT
    query_name,
    ROUND(AVG(rating / position), 2) AS quality, 
    ROUND(
        COUNT(CASE WHEN rating < 3 THEN 1 END) / COUNT(*) * 100,
        2
    ) AS poor_query_percentage
FROM 
    Queries

GROUP BY 
    query_name;

THOUGHTS: 
  
    With this query we are analyzing search performence in system like : 
- search engine, 
- help center, 
- e-commerce platform
- internal knowledge base
______________________________________________________________________________________

1193. Monthly Transactions I




Write an SQL query to find for each month and country, the number of transactions and their 
total amount, the number of approved transactions and their total amount.

SOLUTION: 

SELECT
    DATE_FORMAT(trans_date, '%Y-%m') AS month,
    country,
    COUNT(state) AS trans_count, 
    COUNT(CASE WHEN state = "approved" THEN 1 END) AS approved_count,
    SUM(amount)AS trans_total_amount,
    SUM(CASE WHEN state = "approved" THEN amount ELSE 0 END ) AS approved_total_amount
FROM 
    Transactions
GROUP BY 
    month, country;



___________________________________-

1174. Immediate Food Delivery II

1. If the customer's preferred delivery date is the same as the order date, then the order is called immediate; 
otherwise, it is called scheduled.

2. The first order of a customer is the order with the earliest order date that the customer made. 
It is guaranteed that a customer has precisely one first order.

3. Write a solution to find the percentage of immediate orders in the first orders of all customers, 
rounded to 2 decimal places.

_________________________________________
                                         TRIAL (1)

WITH fist_orders AS(
SELECT 
    delivery_id,
    customer_id,
    order_date,
    customer_pref_delivery_date,
CASE 
    WHEN customer_pref_delivery_date = order_date THEN 'first_order'
    ELSE 'scheduled_date'
 END AS immediate_order_status
FROM Delivery
)
SELECT*
FROM fist_orders;

                                           TRIAL(2)

WITH fist_orders AS(
SELECT 
    delivery_id,
    customer_id,
    order_date,
    customer_pref_delivery_date,
CASE 
    WHEN customer_pref_delivery_date = order_date THEN 'immediate'
    ELSE 'scheduled'
 END AS immediate_order_status
FROM Delivery
ORDER BY immediate_order_status ASC
)
SELECT
ROUND(SUM(DISTINCT immediate_order_status = 'immediate')/ COUNT(*) *100 ,2) AS immediate_percentage
FROM fist_orders;


Solution:

WITH first_orders AS (
    SELECT
        delivery_id,
        customer_id,
        order_date,
        customer_pref_delivery_date,
        CASE 
            WHEN customer_pref_delivery_date = order_date THEN 'immediate'
            ELSE 'scheduled'
        END AS immediate_order_status
    FROM Delivery d
    WHERE order_date = (
        SELECT MIN(order_date)
        FROM Delivery
        WHERE customer_id = d.customer_id
    )
)

SELECT
    ROUND(SUM(order_date = customer_pref_delivery_date) / COUNT(*) * 100, 2) AS immediate_percentage
FROM first_orders;


                                  Thoughts
1. In this code we are using CTE to calculate the immediate first order percentage. I broke the excercise into several parts and tried to
solve it. So the fist think I did was to use the CASE WHEN conditional logic to create a new column and classify the orders to imemdiate
and scheduled orders ultimately trying to find the order status:

CODE: 
        CASE 
            WHEN customer_pref_delivery_date = order_date THEN 'immediate'
            ELSE 'scheduled'
        END AS immediate_order_status


2. In the second part of the code we are going to find the order that the customer made in partcular using customer_id. 
In total we have 7 order and that 4 customers made these orders but the delivery was 7 time. The thing is we need to select only fist
order of our customers. 

 WHERE order_date = (
        SELECT MIN(order_date)
        FROM Delivery
        WHERE customer_id = d.customer_id

In this code we are using correlated subquery to filter only the first orders of our customers by using MIN function to filter fist orders,
doing the inner join on customer_id, why on customer_id becuase the the same customer could have doine multiple orders but we only need the
fist one in this excercise.

3. So here in the 3rd part of our chellange we are summing the summing our immediate order and diving it by the total order. Meaning
2/4*100. So it give us 2 which is 50%. 

 ROUND(SUM(immediate_order_status = 'immediate') / COUNT(*) * 100, 2) AS immediate_percentage
FROM first_orders;
_____________________
